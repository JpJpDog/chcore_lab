问题1
在linker-aarch64.lds.in中指定了物理内存布局
这是一个指定链接时section位置的文件，链接成可执行文件后运行时，就加载到对应位置的物理内存上

问题2
不用回答

问题3
1. 页表中存的下一级页表的地址是物理地址，因为页表都映射在内核空间中，MMU可以简单通过+offset的方法获得虚拟地址交给内核。
2. 内核中的页表基地址是虚拟地址，是MMU或者TTBR通过+offset转化来的，内核的内存操作也需要地址翻译，用虚拟地址才能直接改变页表项。

问题4
1. 最大页表大小为(1+512+512^2+512^3)*4K约为512G，但实际不可能把虚拟地址全部用完。假设物理地址加交换空间为8G，大约有(8G/4K/512)=4K个最后一级页，大小为16M。
原因是页表中的一个页项只占8byte，但可以映射4Kbyte的地址，而且采用多级页表，没用到的区域不会分配页表页。
2. AArch64有两个页表基地址寄存器TTBR，x86只有一个。两个寄存器可以让不同进程的内核共用一个页表，每个进程的用户态一个页表。让内核的实现更方便。


问题5
需要。因为一个进程的内核和用户的地址空间仍是相同的，用户可以访问内核地址。

问题6
1. 内核要映射256M的空间，用大页比较省页表占的内存。第一个进程的内核空间必须在boot阶段映射。其他内核空间由第一个进程映射。
2. 用户操作内存时会经过MMU翻译，翻译拿到页表项中有权限的设置，可以检查。

